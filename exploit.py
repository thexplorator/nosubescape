import argparse
import socket
import requests
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed

# Disable warnings for insecure connections
requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

class BruteForcer:
    def __init__(self, domain, wordlist, threads, timeout):
        self.domain = domain
        self.wordlist = wordlist
        self.threads = threads
        self.timeout = timeout
        self.subdomains = []
        self.virtualhosts = []
        self.lock = threading.Lock()

    def load_words(self):
        with open(self.wordlist, 'r') as f:
            return [line.strip() for line in f if line.strip()]

    def resolve_subdomain(self, subdomain):
        host = f"{subdomain}.{self.domain}"
        try:
            ip = socket.gethostbyname(host)
            with self.lock:
                self.subdomains.append((host, ip))
            return host, ip
        except socket.gaierror:
            return None

    def check_virtualhost(self, host, ip):
        url = f"http://{ip}/"
        headers = {'Host': host}
        try:
            resp = requests.get(url, headers=headers, timeout=self.timeout, verify=False)
            # Consider any response other than 404 as a positive virtual host
            if resp.status_code != 404:
                with self.lock:
                    self.virtualhosts.append((host, ip, resp.status_code))
                return host, ip, resp.status_code
        except requests.RequestException:
            return None

    def run(self):
        words = self.load_words()
        print(f"[*] Loaded {len(words)} words from wordlist")

        # Stage 1: subdomain resolution
        print(f"[*] Starting DNS resolution with {self.threads} threads...")
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            futures = {executor.submit(self.resolve_subdomain, w): w for w in words}
            for future in as_completed(futures):
                result = future.result()
                if result:
                    host, ip = result
                    print(f"[+] Found subdomain: {host} -> {ip}")

        if not self.subdomains:
            print("[-] No subdomains resolved. Exiting.")
            return

        # Stage 2: check virtual hosts
        print(f"[*] Checking for virtual hosts on resolved IPs...")
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            futures = []
            for host, ip in self.subdomains:
                futures.append(executor.submit(self.check_virtualhost, host, ip))
            for future in as_completed(futures):
                result = future.result()
                if result:
                    host, ip, code = result
                    print(f"[+] Virtual host: {host} ({ip}) responded with status {code}")

        # Summary
        print("\n[Summary]")
        print(f"Resolved subdomains ({len(self.subdomains)}):")
        for host, ip in self.subdomains:
            print(f" - {host}: {ip}")

        print(f"\nVirtual hosts ({len(self.virtualhosts)}):")
        for host, ip, code in self.virtualhosts:
            print(f" - {host} ({ip}) -> HTTP {code}")


def main():
    parser = argparse.ArgumentParser(description="Brute force subdomains and virtual hosts")
    parser.add_argument('-d', '--domain', required=True, help='Target domain (e.g. example.com)')
    parser.add_argument('-w', '--wordlist', required=True, help='Path to subdomain wordlist')
    parser.add_argument('-t', '--threads', type=int, default=20, help='Number of threads (default: 20)')
    parser.add_argument('-o', '--timeout', type=int, default=5, help='Request timeout in seconds (default: 5)')
    args = parser.parse_args()

    bf = BruteForcer(domain=args.domain, wordlist=args.wordlist, threads=args.threads, timeout=args.timeout)
    bf.run()

if __name__ == '__main__':
    main()

